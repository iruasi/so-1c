fd_max: Es un entero con el que vamos a mantener una traza de cuál es el file descriptor de socket mas grande hasta el momento.
		Lo necesita select() para funcionar y se lo pasamos por parametro; tenemos que pasarlo como "fd_max + 1".
		
read_fd y master_fd:	Son conjuntos donde se almacenan file descriptors de sockets. 
					¿Por qué tenemos 2 conjuntos? Porque select() modifica al conjunto que le pasas por parametro, y entonces si solo
					utilizaremos un único conjunto, cuando hacemos call del select(), todos los sockets que no esten "ready" los perdemos.
					Entonces en master siempre vamos a ir agregando los sockets que querramos tener en cuenta, y el read_fd lo acutalizamos y
					se lo entregamos a select() para que lo modifique como quiera. 

FD_ZERO(&cjto):  		Es un MACRO (no una funcion) que limpia y prepara los conjuntos que querramos usar. Los deja vacios y listos.

FD_SET(sock_fd, &cjto):	Es otro MACRO que sirve para agregar un socket un conjunto particular. En general, siempre vamos a agregar sockets al master_fd

FD_SET(sock_lis_cpu, &master_fd);	Acá estamos agregando un socket de listen para los procesos de consola, en el conjunto master.  

fd_max = (sock_lis_con > sock_lis_cpu)? sock_lis_con : sock_lis_cpu;
						Esta es una manera simplona de ver cual es el socket_fd mas grande.. Como de momento solo contemplamos conexiones de CPU y Consola,
						nos sirve. Pero a futuro hay que implementar una manera mas elegante de ir actualizando este maximo. Podriamos tomar ventaja de que
						todo socket que nos importa ya existe en el conjunto master_fd...


while (1){	Vamos a usar un ciclo infinito para ir atendiendo a todas las cosas que hace Kernel...
			No sé si esto va a mantenerse así a futuro.. pero es muy posible que sí. Y que salga del ciclo cuando "apaguemos" el proceso. 
	
read_fd = master_fd;	Antes de hacer el select() actualizamos el read_fd para que contemple a todos los sockets que nos interesan

ready_fds = select(fd_max + 1, &read_fd, NULL, NULL, NULL); 
						Select recibe por primer parámetro el valor máximo de entre todos los sockets considerados, aumentado en 1.
						El segundo parámetro es para poner el conjunto de lectura. El tercero y cuarto son para cjtos de escritura y excepciones, pero no interesan.
						El ultimo parámetro es para el timeout. NULL significa que al toque va a estar chequeando que hayan sockets listos.

						Ahora select() se fija qué sockets del conjunto read_fd estan listos para usarse, y lo que nos retorna por respuesta es la CANTIDAD
						de sockets que estan listos. Si mi ready_fd contempla al stdin, el stdout y una Consola, pero solo estan listos stdout y Consola, el
						valor de retorno va a ser 2. Si algo falla, retorna -1. Solo retorna 0 si el timeout se termina, pero como le dimos NULL de timeout, nunca retornaría 0...

						Hasta que select() no detecte ninguna conexion nueva o lista, va a trabar la ejecucion del programa. Por eso cuando iniciamos el proceso Kernel,
						va a llegar hasta el select() y se detiene ahi en forma indefinida, hasta que suceda algun evento con los sockets vigilados.